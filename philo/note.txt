
### **1. Set Up the Project Structure**
- Create a directory named `philo/`.
- Inside `philo/`, create the following files:
	- `Makefile`
	- Header files (`*.h`)
	- Source files (`*.c`)

### **2. Implement the Makefile**
- Define rules for:
	- `NAME`: The name of the executable.
	- `all`: Compile the program.
	- `clean`: Remove object files.
	- `fclean`: Remove object files and the executable.
	- `re`: Recompile the program.
- Use `cc` with the flags `-Wall -Wextra -Werror`.
- Ensure the Makefile does not relink unnecessarily.

### **3. Implement Core Data Structures**
- Define the necessary data structures in the header file(s):
	- `Philosopher`: A structure to hold information about each philosopher (e.g., ID, state, fork status).
	- `Fork`: A structure to represent the forks and their associated mutexes.
	- `Simulation`: A structure to manage the overall simulation state, including philosopher threads and timing information.

### **4. Create Utility Functions**
- Implement utility functions for tasks such as:
	- Time management (e.g., calculating the current time in milliseconds).
	- Thread-safe printing to ensure logs are not mixed up.
	- Initialization of philosophers, forks, and mutexes.

### **5. Implement the Philosopher Threads**
- Create a function for the philosopher routine:
	- Eating: Acquire both forks (using mutexes), then eat for the specified time.
	- Sleeping: Release the forks and sleep for the specified time.
	- Thinking: Transition to the thinking state after sleeping.
- Ensure that each philosopher is represented by a separate thread.
- Handle the case where a philosopher dies due to starvation.

### **6. Implement Fork Management**
- Protect access to forks with mutexes:
	- Ensure that a philosopher can only pick up a fork if it is available.
	- Properly lock and unlock mutexes when philosophers pick up and put down forks.

### **7. Implement Death Detection**
- Monitor each philosopher to check if they die of starvation:
	- Implement a mechanism to track the last meal time of each philosopher.
	- If the time since the last meal exceeds `time_to_die`, declare the philosopher dead.
	- Ensure that the simulation stops as soon as one philosopher dies.

### **8. Handle the Optional Argument**
- Implement logic to handle the optional argument `[number_of_times_each_philosopher_must_eat]`:
	- If provided, the simulation should stop once all philosophers have eaten the specified number of times.
	- If not provided, the simulation should continue until a philosopher dies.

### **9. Implement Proper Cleanup**
- Ensure that all dynamically allocated memory is freed:
	- Destroy all mutexes when the simulation ends.
	- Free any allocated memory for philosophers and forks.
- Ensure no memory leaks are present.

### **10. Test the Program**
- Create various test cases to validate the behavior of the program:
	- Test with different numbers of philosophers.
	- Test edge cases like having only one philosopher.
	- Validate the program with short and long `time_to_die`, `time_to_eat`, and `time_to_sleep` values.
	- Check the programâ€™s response to the optional argument.
- Ensure the program adheres to the norms and does not crash unexpectedly.

### **11. Final Review and Submission**
- Double-check the code to ensure it follows the Norm.
- Verify that the program does not produce any segmentation faults, bus errors, or other crashes.
- Commit the final version to the assigned Git repository.

